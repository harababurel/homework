Chapter 5. Interrupts
=====================


**Interrupt Vector Table** - loaded at OS loading time, in the first 1024 bytes of RAM.

**IHR** - Interrupt Handling Routine

```
Addr(IHR(0)) - at 0000:0000
Addr(IHR(1)) - at 0000:0004
Addr(IHR(2)) - at 0000:0008
---------------------------
Addr(IHR(k)) - at 0000:(k*4)
```
^ specific to MS-DOS and Windows. *NIX provides a list of callable functions instead of a table of IHR addresses (which can be modified).

Each `Addr(IHR())` points to a function for some interrupt (handler).


Types of Interrupt Handling Routine:

    written by the vendor of the CS
    written by the designers of the OS
    written by the user

## Types of interrupts:

    hardware interrupts (=BIOS interrupts)

        automatically generated, as a reaction to external causes
        the routines are loaded in memory from the ROM-BIOS files at CS startup)
        the program ALWAYS resumes

    exceptions

        automatically generated, as a result of some internal causes

            zero division
            attempt of running an inexistent instruction
            accessing restricted memory area

        the program DOES NOT usually resume

    software interrupts (=traps)

        never automatically generated
        the programmer initiate execution control transfer to the corresponding IHR (handler) by using the INT instruction
        are called software interrupts because they are SOFTWARE invoked by an explicit instruction

All interrupts can be initiated by the programmer by the INT instruction.

Those interrupts that can ONLY be initiated by the programmer by INT are software interrupts.

Most well-known hardware interrupts (`INT 0` to `INT 15`):

* `INT 8` - clock's hardware interrupt (system timer).
    It identified by IRQ 0.

* `INT 9` - the keybord interrupt.

        It is identified by IRQ 1.
        It is generated by the keyboard at every keypress and release.
        DO NOT disble it, because the CS will not respond to CTRL+ALT+DEL
        Actual actions performed by the corresponding IHR are:

            BIOS acts by reading the key scan-code,

                         converting it to ASCII,
                         storing this pair of attributes in the keyboard buffer, starting at memory address 0000:041Ch, on 32 bytes (enough for 16 characters (for each character, one scan code + one ASCII code))

    INT 76h - Hard Disk Controller

    INT 70h - The Real-Time ClockInterrupt (IRQ 8)
        It is activated 1024 times/second for managing the real time system clock.

    INT 75h - FPU - Floating Point Interrupt (IRQ 13)
        It is generated by the mathematical coprocessor at every floating-point exception.
        Allows floating point operations.

# Exceptions

* `INT 0` - Zero Divide Interrupt.
    * Generated every time when a so-called zero-divide condition arises:
        * quotient overflow after a division (DIV or IDIV)
        * attempting to perform a division by 0
        * explicit issuing of this interrupt by invoking it as `INT 0`

* `INT 1` - Single Step.
    * Initiated by the processor after each machine instruction, if TF = 1.
    * Used at debugging, for step by step execution.

* `INT 2` - Non-Maskable Interrupt.
    * The only interrupt that cannot be masked (=disabled) by the `CLI` instruction (**CL**ear **I**nterrupts).
    * The CLI defines a section where no interrupts can be performed (critical section):

        ```
        CLI
        ;some instructions here
        SLI
        ```
    * It is the only interrupt that can be issued in a critical session.

* `INT 3` - Breakpoint Interrupt.
    * Used by debuggers for establishing breakpoints.

* `INT 4` - Overflow Interrupt.
    * Issued when an overflow arises during an arithmetic operation.
    * More precisely, it is issued when an instruction `INTO` (interrupt on overflow) is run and `OF = 1`.
    * If `OF = 0`, then `INTO` results in a `NOP` (no operation).
    * Instruction `INTO` allows for defining an own routine of managing an overflow. It has the following effect:

    ```
    INTO <-> if (OF=1) | PUSHF               ;push the flags onto the stack, so they can be restored later
                       | TF:=0; IF:=0        ;set these flags to 0
                       | CALL FAR 0000:0010h ;call routine
    ```

* `INT 6` - Invalid Opcode
    * Expresses that the microprocessor has encountered an illegal instruction code.
    * For example:

    ```
    add ax,2    ;ok, no problems
    a db 199    ;illegal instruction - the program thinks that this byte represents an operation code, at runtime.
    a db 13     ;maybe this works - 13 might be the operation code of some valid instruction


Next time: **Software interrupts**
