# Chapter 5. Interrupts

*Course notes, 9th of December 2015*

## Interrupt Vector Table

Loaded at OS loading time, in the first 1024 bytes of RAM.

**IHR** - Interrupt Handling Routine

```asm
Addr(IHR(0)) - at 0000:0000
Addr(IHR(1)) - at 0000:0004
Addr(IHR(2)) - at 0000:0008
---------------------------
Addr(IHR(k)) - at 0000:(k*4)
```
Each 4-byte memory location in the Interrupt Vector Table contains the address of some function (denoted by `Addr(IHR())`) which is called when specific interrupts are issued.

**NOTE**: this table is specific to `MS-DOS` and `Windows`. `*NIX` provides a list of callable functions instead of a table of IHR addresses (which can be modified).

Types of **Interrupt Handling Routines**:
* written by the vendor of the CS
* written by the designers of the OS
* written by the user

## Types of interrupts

* hardware interrupts (=`BIOS` interrupts)
    * automatically generated, as a reaction to external causes
    * the routines are loaded in memory from the `ROM-BIOS` files at CS startup)
    * the program **ALWAYS** resumes
* exceptions
    * automatically generated, as a result of some internal causes:
        * zero division
        * attempt of running an inexistent instruction
        * accessing restricted memory area
    * the program **DOES NOT** usually resume
* software interrupts (=**traps**)
    * never automatically generated
    * the programmer initiates execution control transfer to the corresponding IHR (handler) by using the `INT` instruction
    * are called software interrupts because they are SOFTWARE invoked by an explicit instruction

All interrupts can be initiated by the programmer by the *INT* instruction.

Those interrupts that can **ONLY** be initiated by the programmer by `INT` are software interrupts.

## Examples of interrupts

### Hardware interrupts

Most well-known **hardware** interrupts (`INT 0` to `INT 15`):

* `INT 8` - **Clock's Hardware Interrupt** (system timer).
    * It identified by `IRQ 0`.
* `INT 9` - **Keyboard Interrupt**.
    * It is identified by `IRQ 1`.
    * It is generated by the keyboard at every keypress and release.
    * **DO NOT** disable it, because the CS will not respond to `CTRL+ALT+DEL`
    * BIOS reacts by:
        * reading the key scan-code
        * converting it to ASCII
        * storing this pair of attributes (scan-code + ASCII) in the keyboard buffer, starting at memory address `0000:041Ch`, on 32 bytes (enough for 16 characters - for each character, one scan code + one ASCII code)
* `INT 76h` - **Hard Disk Controller**
* `INT 70h` - **The Real-Time Clock Interrupt** (`IRQ 8`)
    * It is activated 1024 times/second for managing the real time system clock.
* `INT 75h` - **FPU - Floating Point Interrupt** (`IRQ 13`)
    * It is generated by the mathematical coprocessor at every floating-point exception.
    * Allows floating point operations.

### Exceptions

* `INT 0` - **Zero Divide Interrupt**.
    * Generated every time when a so-called zero-divide condition arises:
        * quotient overflow after a division (`DIV` or `IDIV`)
        * attempting to perform a division by 0
        * explicit issuing of this interrupt by invoking it as `INT 0` (probably no practical reason to do this)
* `INT 1` - **Single Step**.
    * Initiated by the processor after each machine instruction, if `TF = 1`.
    * Used at debugging, for step by step execution.
* `INT 2` - **Non-Maskable Interrupt**.
    * The only interrupt that cannot be masked (=disabled) by the `CLI` instruction (**CL**ear **I**nterrupts).
    * The `CLI` defines a section where no interrupts can be performed (*critical section*):

        ```asm
        CLI
        ;some instructions here
        ;but no interruptions
        ;or maybe some interruptions (not sure)
        ;but they surely won't be issued
        SLI
        ```
    * It is the only interrupt that can be issued in a critical session.
* `INT 3` - **Breakpoint Interrupt**.
    * Used by debuggers for establishing breakpoints.
* `INT 4` - **Overflow Interrupt**.
    * Issued when an overflow arises during an arithmetic operation.
    * More precisely, it is issued when an instruction `INTO` (**Int**errupt on **O**verflow) is run and `OF = 1`.
    * If `OF = 0`, then `INTO` results in a `NOP` (**No** **O**peration).
    * The instruction `INTO` allows for defining an own routine of managing an overflow. It has the following effect:

        ```asm
        INTO ;if (OF=1)

        ;is equivalent to:

        PUSHF               ;push the flags onto the stack, so they can be restored later
        TF:=0; IF:=0        ;set these flags to 0
        CALL FAR 0000:0010h ;call routine
        ```
* `INT 6` - **Invalid Opcode**.
    * Expresses that the microprocessor has encountered an illegal instruction code.
    * For example:

        ```asm
        add ax,2    ;ok, no problems
        a db 199    ;illegal instruction - the processor thinks that this byte represents an operation code, at runtime.
        b db 13     ;maybe this works - 13 might be the operation code of some valid instruction
        ```

### Software interrupts (11th of December)

* Classified in:
    * `BIOS` interrupts.
    * `DOS` interrupts.
    * Other interrupts (user defined).
* The main `BIOS` interrupts are (some of them):
    * `11h` - Returns the list of the `BIOS` devices installed in the CS.
    * `12h` - Returns the size of the `RAM`.
    * `16h` - Keyboard management services.
    * `17h` - Printer management.
    * `19h` - OS load services. Similar to `Ctrl-Alt-Del`.
    * `1Ch` - Called `18.2` times/second by `INT 8`. The corresponding `IHR` does not do anything specific, letting the user define their own routine.
* The main `DOS` **interrupts** are:
    * `20h` - Program termination. As a result, memory is freed.
    * `27h` - Terminate and stay resident. Ends the execution of the current program letting it (or a part of it) resident in memory.
    * `2Eh` - `DOS` Execute Command. *Undocumented*. Runs a `DOS` command.
    * `33h` - The mouse interrupt. Groups all the functions necessary when working with the mouse.
* The main `DOS` **functions** are:
    * Memory management functions
        * `48h` - Allocate a memory block and returns a pointer to its beginning.
        * `49h` - Frees a memory area
    * Process management functions
        * `4Ch` - Quite with exit-code (EXIT). Returns an error level set in `al`.
    * Disk functions
        * `19h` - Get default disk number.
    * Functions for files and directories
        * TODO
    * I/O with character peripheral devices
        * `01h` - Reads a character from `STDIN` and displays it to the `STDOUT`.
        * `02h` - Displays a character to the `STDOUT`.
    * Other functions
        * `25h` - Set interrupt vector. Modifies the address of a `IHR`. Useful for defining custom routines.
        * `35h` - Get interrupt vector. Obtains the address of an `IHR` (`segment:offset`).

**Note** the difference between:

```asm
mov ah, 4ch     |      mov ax, 4c00h
int 21h         |      int 21h
```

Difference: the code in the `al` register is considered to be the exit-code of the application.

What the `INT` instruction does:

```asm
jmp
call ~= jmp  + return address
int  ~= call + save flags
```

`(!)` An interrupt handling routine is a **critical session**, because it can't be further interrupted by some other `IHR.`

`(!)` Any `IHR` must end with an `IRET` instruction (restores the `FLAGS` registers from the stack and transfers the control to the instruction whose `FAR` address is found on top of the stack).


### Structure of PSP (Program Segment Prefix) - in memory

Offset  |Length|Semantics
:------:|:----:|:--------------------------------------------------------------------
`00h`   |2     |Code of `INT 20h` - program termination
`02h`   |2     |Memory size in paragraphs (the end of memory occupied by the program)
`04h`   |1     |Reserved
`05h`   |1     |Code of `INT 21h` - `DOS` functions
`...`   |`...` |`...`
`81h`   |127   |Command line - so it is possible to access command line parameters.


The `PSP` has a **fixed** size (256 bytes).

The `PSP` is useful for:
* Restoring the context in case of a program execution that goes wrong (*not sure*).
* Accessing the command line parameters in an assembly program.

### Structure of an EXE Header - on disk

* The validity of an EXE file is determined (by the OS) using two criteria:
    * the EXE signature, located at the beginning of the header, should always be `5A4Dh` = `'MZ'` (the initials of the designer of the file format, Mark Zbikowski),
    * the checksum.
* The EXE Header has a variable size.
