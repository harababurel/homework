# Chapter 5. Interrupts

*Course notes, 9th of December 2015*

## Interrupt Vector Table

Loaded at OS loading time, in the first 1024 bytes of RAM.

**IHR** - Interrupt Handling Routine

```
Addr(IHR(0)) - at 0000:0000
Addr(IHR(1)) - at 0000:0004
Addr(IHR(2)) - at 0000:0008
---------------------------
Addr(IHR(k)) - at 0000:(k*4)
```
Each 4-byte memory location in the Interrupt Vector Table contains the address of some function (denoted by `Addr(IHR())`) which is called when specific interrupts are issued.

**NOTE**: this table is specific to `MS-DOS` and `Windows`. `*NIX` provides a list of callable functions instead of a table of IHR addresses (which can be modified).

Types of **Interrupt Handling Routines**:
* written by the vendor of the CS
* written by the designers of the OS
* written by the user

## Types of interrupts

* hardware interrupts (=`BIOS` interrupts)
    * automatically generated, as a reaction to external causes
    * the routines are loaded in memory from the `ROM-BIOS` files at CS startup)
    * the program **ALWAYS** resumes
* exceptions
    * automatically generated, as a result of some internal causes:
        * zero division
        * attempt of running an inexistent instruction
        * accessing restricted memory area
    * the program **DOES NOT** usually resume
* software interrupts (=**traps**)
    * never automatically generated
    * the programmer initiates execution control transfer to the corresponding IHR (handler) by using the `INT` instruction
    * are called software interrupts because they are SOFTWARE invoked by an explicit instruction

All interrupts can be initiated by the programmer by the *INT* instruction.

Those interrupts that can **ONLY** be initiated by the programmer by `INT` are software interrupts.

## Examples of interrupts

### Hardware interrupts

Most well-known **hardware** interrupts (`INT 0` to `INT 15`):

* `INT 8` - **Clock's Hardware Interrupt** (system timer).
    * It identified by `IRQ 0`.
* `INT 9` - **Keyboard Interrupt**.
    * It is identified by `IRQ 1`.
    * It is generated by the keyboard at every keypress and release.
    * **DO NOT** disable it, because the CS will not respond to `CTRL+ALT+DEL`
    * BIOS reacts by:
        * reading the key scan-code
        * converting it to ASCII
        * storing this pair of attributes (scan-code + ASCII) in the keyboard buffer, starting at memory address `0000:041Ch`, on 32 bytes (enough for 16 characters - for each character, one scan code + one ASCII code)
* `INT 76h` - **Hard Disk Controller**
* `INT 70h` - **The Real-Time Clock Interrupt** (`IRQ 8`)
    * It is activated 1024 times/second for managing the real time system clock.
* `INT 75h` - **FPU - Floating Point Interrupt** (`IRQ 13`)
    * It is generated by the mathematical coprocessor at every floating-point exception.
    * Allows floating point operations.

### Exceptions

* `INT 0` - **Zero Divide Interrupt**.
    * Generated every time when a so-called zero-divide condition arises:
        * quotient overflow after a division (`DIV` or `IDIV`)
        * attempting to perform a division by 0
        * explicit issuing of this interrupt by invoking it as `INT 0` (probably no practical reason to do this)
* `INT 1` - **Single Step**.
    * Initiated by the processor after each machine instruction, if `TF = 1`.
    * Used at debugging, for step by step execution.
* `INT 2` - **Non-Maskable Interrupt**.
    * The only interrupt that cannot be masked (=disabled) by the `CLI` instruction (**CL**ear **I**nterrupts).
    * The `CLI` defines a section where no interrupts can be performed (*critical section*):

        ```asm
        CLI
        ;some instructions here
        ;but no interruptions
        ;or maybe some interruptions (not sure)
        ;but they surely won't be issued
        SLI
        ```
    * It is the only interrupt that can be issued in a critical session.
* `INT 3` - **Breakpoint Interrupt**.
    * Used by debuggers for establishing breakpoints.
* `INT 4` - **Overflow Interrupt**.
    * Issued when an overflow arises during an arithmetic operation.
    * More precisely, it is issued when an instruction `INTO` (**Int**errupt on **O**verflow) is run and `OF = 1`.
    * If `OF = 0`, then `INTO` results in a `NOP` (**No** **O**peration).
    * The instruction `INTO` allows for defining an own routine of managing an overflow. It has the following effect:

        ```asm
        INTO ;if (OF=1)

        ;is equivalent to:

        PUSHF               ;push the flags onto the stack, so they can be restored later
        TF:=0; IF:=0        ;set these flags to 0
        CALL FAR 0000:0010h ;call routine
        ```
* `INT 6` - **Invalid Opcode**.
    * Expresses that the microprocessor has encountered an illegal instruction code.
    * For example:

        ```asm
        add ax,2    ;ok, no problems
        a db 199    ;illegal instruction - the processor thinks that this byte represents an operation code, at runtime.
        b db 13     ;maybe this works - 13 might be the operation code of some valid instruction
        ```

### Software interrupts (11th of December)
